<!DOCTYPE html>
<html lang="en">
<head>
    <title>HLSL Constant Buffer Packing Rules & Layout Visualizer</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="description" content="Learn HLSL constant buffer packing rules and visualize the memory layout of your own custom cbuffers!" />
    <meta name="robots" content="index, archive" />
    <meta name="keywords" content="HLSL, DirectX, Direct3D, D3D11, D3D12, DX11, DX12, constant buffer, packing rules, struct packing, struct layout, cbuffer" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title" content="HLSL Constant Buffer Packing Rules & Layout Visualizer" />
    <meta property="og:description" content="Learn HLSL constant buffer packing rules and visualize the memory layout of your own custom cbuffers!" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://maraneshi.github.io/HLSL-ConstantBufferLayoutVisualizer/" />
    <meta property="og:image" content="https://maraneshi.github.io/HLSL-ConstantBufferLayoutVisualizer/screen3.png" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="HLSL Constant Buffer Packing Rules & Layout Visualizer" />
    <meta name="twitter:image" content="https://maraneshi.github.io/HLSL-ConstantBufferLayoutVisualizer/screen3.png" />
    <meta name="twitter:description" content="Learn HLSL constant buffer packing rules and visualize the memory layout of your own custom cbuffers!" />
    <meta name="twitter:creator" content="@maraneshi" />
    <meta name="twitter:site" content="@maraneshi" />
    <!-- NOTE: I don't know whether it's worth doing this at all. The W3 image source is there for the squiggly lines in Monaco. -->
    <META HTTP-EQUIV='Content-Security-Policy' CONTENT="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src data: 'self' w3.org/svg/2000;">
    <meta name="google-site-verification" content="ZJ8tLJVKf9I0aKYguit8CTb2jMFPQLpaJhT1YpQ4eNo" />
</head>
<body>
    <style>
        .code {
            font-family: Consolas, monospace;
            font-size: 14px;
            white-space: pre;
        }
        code {
            font-family: Consolas, monospace;
            white-space: pre;
            background-color: #EEEEEE;
            font-size: 0.92em;
        }
        .resizer {
            background-color: #777777;
            cursor: ew-resize;
            min-height: 100%;
            min-width:2px;
            width: 2px;
            padding: 8px;
            background-clip: content-box;
        }
        .resizer_vert {
            background-color: #777777;
            cursor: ns-resize;
            min-width: 100%;
            min-height: 2px;
            height: 2px;
            padding: 8px;
            background-clip: content-box;
        }
        :root {
            font-size: 18px;
        }
        p {
            line-height: 1.3em;
            text-align: justify;
        }
        li {
            line-height: 1.3em;
            margin-block-end: 0.5em;
        }
        sup {
            line-height: 100%;
            font-size:0.89em;
            vertical-align: top;
        }
        a {
            text-decoration:none;
        }
        a:hover {
            text-decoration:underline;
        }
        #CBV_root_container {
            font-size: initial;
            line-height: initial;
        }
        h4 {
            margin-block-start: 0.5em;
            margin-block-end: 0.5em;
        }
        h3 {
            font-size: 1.25em;
        }
        .rule_definition {
            color: #2d14ad;
            /*padding-top: 16px;*/
        }
        .rule_definition > code {
            background-color: #d3ebff;
        }
        .keyword {
            color: #0000ff;
        }
        .bracket0 {
            color: #0431fa;
        }
        .bracket1 {
            color: #319331;
        }
        .bracket2 {
            color: #7b3814;
        }
        .number {
            color: #098658;
        }
        .CBV_example {
            width: calc(100% - 18px);
            padding: 8px;
            border-top: 2px solid #777777;
            border-bottom: 2px solid #777777;
            border-radius: 12px;
        }
        .CBV_left {
            flex: auto;
            margin-left: 8px;
            margin-right: 8px;
        }
        .CBV_middle {
            flex: auto;
            margin-left: 8px;
            /*margin-right: 8px;*/
            margin-right:16px; /* includes margin from CBV_right, better for mobile layout */
        }
        .CBV_right {
            flex: 1; /* this effectively aligns it to the right side */
            /*margin-left: 8px;*/
        }
        .CBV_example_container {
            margin-left: -8px; /* strip padding for mobile layout */
            margin-top: -8px; /* looks more consistent with the above */
            display: flex;
            overflow: auto;
            width: calc(100% + 8px);
            flex-wrap: wrap;
        }
        dfn {
            font-weight:bold;
            font-style:normal;
        }
        var {
            font-weight:normal;
            font-style:normal;
            font-family:math;
        }
        body {
            counter-reset: footnote;
        }
        a[href^="#fn"] ::after {
            counter-increment: footnote;
            content: counter(footnote)
        }
    </style>
    <style title="CBV Dark Theme">
        /* based on VS-Dark from Monaco */
        :root {
            color: rgb(212, 212, 212);
            background-color: rgb(30, 30, 30);
        }

        input {
            color: rgb(204, 204, 204);
            background-color: rgb(60, 60, 60);
        }

        button {
            color: rgb(255, 255, 255);
            background-color: rgb(14, 99, 156);
        }
        code {
            background-color: #3C3C3C;
        }
        .rule_definition {
            color: #A0A0F4;
        }
        .rule_definition > code {
            background-color: #251960;
        }
        a {
            color: #4e94de;
        }
        .keyword {
            color: #569cd6;
        }
        .bracket0 {
            color: #ffd700;
        }
        .bracket1 {
            color: #da70d6;
        }
        .bracket2 {
            color: #179fff;
        }
        .number {
            color: #b5cea8;
        }
    </style>
    <main>
        <article>
            <div style="margin: 0px auto; width:fit-content; max-width:100%">
                <h2 style="margin-left:auto; margin-right:auto; width:fit-content">HLSL Constant Buffer Layout Visualizer</h2>
                <div id="CBV_enable_div" style="background-image: url(screen1a.png); background-position: center top; width: 60em; max-width: 100%; height: 146px; margin-bottom: -24px; background-repeat: no-repeat;">
                    <button id="CBV_enable_button" type="button" style="width: 17em; height: 6em; font-size: 1.1em; margin:auto; display:block; max-width:100%" disabled
                            onclick="CBV_Initialize(); this.disabled = true; this.textContent = 'Loading...'">
                        Click to Load Visualizer
                    </button>
                </div>
            </div>
            <div id="CBV_root_container" style="margin: 0px auto;  max-width:100%" hidden>
                <div style="width: 100%; display: flex; justify-content: center;">
                    <div style="float: left; flex: 0; flex-basis: auto; min-width: 20em; width:25em;">
                        <form action="javascript:CBV_VisualizeCBuffer()">
                            <div id="CBV_editor_container" style="width:100%; min-height:12em"></div>
                            <div class="resizer_vert" id="CBV_resizer_vert"></div>
                            <div>
                                <button type="submit">Parse</button>
                                <br />
                                <label for="CBV_auto_parse_delay">Auto-Parse Delay:</label>
                                <input type="range" id="CBV_auto_parse_delay" min="100" max="1500" step="50" value="500" autocomplete="off"
                                       oninput="if (this.value == this.getAttribute('max')) CBV_auto_parse_delay_value.value = 'off'; else CBV_auto_parse_delay_value.value = this.value + 'ms';" />
                                <output id="CBV_auto_parse_delay_value"></output>
                                <script>CBV_auto_parse_delay_value.value = CBV_auto_parse_delay.value;</script>
                                <br />
                                <label for="CBV_expanded_arrays">Expanded Arrays</label>
                                <input type="checkbox" id="CBV_expanded_arrays" checked="checked" autocomplete="off" onchange="window.CBV_VisualizerObject?.SetExpandedArrays(this.checked);" />
                                <br />
                                <label for="CBV_text_alignment">Offset Text Alignment:</label>
                                <input type="number" id="CBV_text_alignment" value="28" min="10" max="200" style="width:3em;" autocomplete="off" oninput="window.CBV_VisualizerObject?.SetTextAlignment(this.value);"  />
                                <br />
                                <label for="CBV_color_shuffle">Shuffle Colors</label>
                                <input type="checkbox" id="CBV_color_shuffle" autocomplete="off" onchange="window.CBV_VisualizerObject?.SetColorShuffle(this.checked);" />
                                <br />
                                <label for="CBV_color_shuffle_subdivisions">Color Shuffle Subdivisions:</label>
                                <input type="number" id="CBV_color_shuffle_subdivisions" value="4" min="1" max="10" style="width:2em" autocomplete="off" oninput="window.CBV_VisualizerObject?.SetColorShuffleSubdivisions(this.value);" />
                                <br />
                                <div id="CBV_color_theme_controls_visualizer_container">
                                    <div id="CBV_color_theme_controls">
                                        <label for="CBV_color_lightness">Color Lightness:</label>
                                        <input type="range" id="CBV_color_lightness" min="0.01" max="1.0" step="0.01" value="0.60" autocomplete="off"
                                               oninput="CBV_color_lightness_value.value = this.value; window.CBV_VisualizerObject?.SetColorLightness(this.valueAsNumber); window.CBV_ExampleVisualizers?.SetColorLightness(this.valueAsNumber);" />
                                        <output id="CBV_color_lightness_value"></output>
                                        <script>CBV_color_lightness_value.value = CBV_color_lightness.value;</script>
                                        <br />
                                        <label for="CBV_color_saturation">Color Saturation:</label>
                                        <input type="range" id="CBV_color_saturation" min="0.01" max="1.0" step="0.01" value="0.60" autocomplete="off"
                                               oninput="CBV_color_saturation_value.value = this.value; window.CBV_VisualizerObject?.SetColorSaturation(this.valueAsNumber); window.CBV_ExampleVisualizers?.SetColorSaturation(this.valueAsNumber);" />
                                        <output id="CBV_color_saturation_value"></output>
                                        <script>CBV_color_saturation_value.value = CBV_color_saturation.value;</script>
                                        <br />
                                        <label for="CBV_color_hue_start">Hue Start:</label>
                                        <input type="range" id="CBV_color_hue_start" min="0" max="359" step="1" value="290" autocomplete="off"
                                               oninput="CBV_color_hue_start_value.value = this.value; window.CBV_VisualizerObject?.SetColorHueStart(this.valueAsNumber); window.CBV_ExampleVisualizers?.SetColorHueStart(this.valueAsNumber);" />
                                        <output id="CBV_color_hue_start_value"></output>
                                        <script>CBV_color_hue_start_value.value = CBV_color_hue_start.value;</script>
                                        <br />
                                        <label for="CBV_color_hue_range">Hue Range:</label>
                                        <input type="range" id="CBV_color_hue_range" min="0" max="360" step="1" value="360" autocomplete="off"
                                               oninput="CBV_color_hue_range_value.value = this.value; window.CBV_VisualizerObject?.SetColorHueRange(this.valueAsNumber); window.CBV_ExampleVisualizers?.SetColorHueRange(this.valueAsNumber);" />
                                        <output id="CBV_color_hue_range_value"></output>
                                        <script>CBV_color_hue_range_value.value = CBV_color_hue_range.value;</script>
                                        <br />
                                        <label for="CBV_dark_theme">Dark Theme</label>
                                        <input type="checkbox" id="CBV_dark_theme" autocomplete="off" onchange="window.CBV_SetDarkTheme(this.checked);" checked="checked" />
                                    </div>
                                </div>
                                <br />
                                <br />
                                <span>Supported Keywords:</span>
                                <br />
                                <span id="CBV_keywords_text" class="code" style="white-space:pre-wrap"></span>
                            </div>
                        </form>
                    </div>
                    <div class="resizer" id="CBV_resizer_horz"></div>
                    <div style="float: right; display:flex;">
                        <div style="float: left; flex: 1; flex-basis: max-content; padding-right: 8px">
                            <text id="CBV_output_text" class="code">
                            </text>
                        </div>
                        <div style="float: right; flex: 2; flex-basis: max-content; padding-left: 8px;">
                            <svg id="CBV_output_svg" class="code">
                            </svg>
                        </div>
                    </div>
                </div>
            </div>
        </article>

        <script>
            var require = { paths: { vs: 'monaco-editor/min/vs' } };
        </script>

        <!-- without preload all these scripts are requested serially, incurring network latency every single time -->
        <link rel="modulepreload" href="main.js" />
        <link rel="modulepreload" href="hlsl_monaco.js" />
        <link rel="modulepreload" href="cbuffer_parser.js" />
        <link rel="modulepreload" href="cbuffer_layout.js" />
        <link rel="modulepreload" href="cbuffer_visualizer.js" />
        <!--<link rel="preload" href="monaco-editor/min/vs/editor/editor.main.js" as="script"/>-->
        <!--<link rel="preload" href="monaco-editor/min/vs/editor/editor.main.nls.js" as="script"/>-->
        <!--<link rel="preload" href="monaco-editor/min/vs/loader.js" as="script"/>-->

        <script type="module">
            import { EnableResizer, ParseHLSLAndVisualizeMonaco, GetSupportedKeywords, SetDarkTheme, CreateMonacoEditor, CBufferVisualizerOptionsDefault } from './main.js';

            window.CBV_SetDarkTheme = SetDarkTheme;

            window.GetVisualizerOptions = () => {
                let options = Object.assign({}, CBufferVisualizerOptionsDefault);
                options.expanded_arrays = CBV_expanded_arrays.checked;
                options.text_alignment = CBV_text_alignment.value;
                options.color_shuffle = CBV_color_shuffle.checked;
                options.color_shuffle_subdivisions = CBV_color_shuffle_subdivisions.value;
                options.color_lightness = CBV_color_lightness.valueAsNumber;
                options.color_saturation = CBV_color_saturation.valueAsNumber;
                options.color_hue_start = CBV_color_hue_start.valueAsNumber;
                options.color_hue_range = CBV_color_hue_range.valueAsNumber;
                options.dark_theme = CBV_dark_theme.checked;
                return options;
            }

            EnableResizer(CBV_resizer_horz, false);
            EnableResizer(CBV_resizer_vert, true);

            let keywords_str = "";
            let keywords = GetSupportedKeywords();
            for (let i = 0; i < keywords.length; i++) {
                keywords_str += keywords[i] + ((i != keywords.length - 1) ? ", " : "");
            }
            CBV_keywords_text.append(keywords_str);

            // function to initialize the custom cbuffer visualizer, used by big button
            window.CBV_Initialize = () => {

                // actual initialization of the entire visualizer, delayed until after Monaco editor script load
                const DelayedInit = () => {
                    window.CBV_monaco_editor = CreateMonacoEditor(CBV_editor_container);

                    window.CBV_VisualizeCBuffer = () => {
                        window.CBV_VisualizerObject = ParseHLSLAndVisualizeMonaco(CBV_monaco_editor, CBV_output_text, CBV_output_svg, GetVisualizerOptions());
                    }

                    window.CBV_monaco_editor.getModel().onDidChangeContent(() => {
                        if (CBV_auto_parse_delay.value != CBV_auto_parse_delay.getAttribute("max")) {
                            clearTimeout(window.CBV_parse_timer);
                            window.CBV_parse_timer = setTimeout(CBV_VisualizeCBuffer, CBV_auto_parse_delay.value);
                        }
                    });
                    //window.CBV_monaco_editor.onDidContentSizeChange(() => { // broken
                    //    CBV_editor_container.style.height = `calc(max(${CBV_monaco_editor.getContentHeight() + 'px'}, ${CBV_editor_container.style.height}))`;
                    //});

                    CBV_color_theme_controls_visualizer_container.appendChild(CBV_color_theme_controls);
                    let text = document.createElement("i");
                    text.append("If you have trouble reading the examples, color and theme controls are in the big visualizer above.");
                    CBV_color_theme_controls_inline_container.replaceChildren(text);

                    CBV_VisualizeCBuffer();
                    CBV_enable_div.remove();
                    CBV_root_container.removeAttribute("hidden");
                }

                // first, we preload the script/CSS data in parallel so we don't incur network latency for every single file sequentially

                const Preload = (file, type) => {
                    let link = document.createElement('link');
                    link.rel = "preload";
                    link.href = file;
                    link.as = type;
                    if (type == "font" || type == "fetch")
                        link.setAttribute("crossOrigin", "");
                    document.head.appendChild(link);
                };
                Preload("monaco-editor/min/vs/editor/editor.main.css", "style");
                Preload("monaco-editor/min/vs/loader.js", "script");
                Preload("monaco-editor/min/vs/editor/editor.main.nls.js", "script");
                Preload("monaco-editor/min/vs/editor/editor.main.js", "script");
                Preload("monaco-editor/min/vs/base/browser/ui/codicons/codicon/codicon.ttf", "font");
                //Preload("monaco-editor/min/vs/base/worker/workerMain.js", "script"); // this doesn't work for unknown reasons
                //Preload("monaco-editor/min/vs/base/common/worker/simpleWorker.nls.js", "fetch"); // this doesn't work for unknown reasons


                // then we try to actually load/execute the scripts/css

                const LoadScript = (file, callback) => {
                    let script = document.createElement('script');
                    script.src = file;
                    if (callback)
                        script.onload = callback;
                    document.body.appendChild(script);
                };

                const LoadCSS = (file, data_name) => {
                    let link = document.createElement('link');
                    link.rel = "stylesheet";
                    link["data-name"] = data_name;
                    link.href = file;
                    document.head.appendChild(link);
                };

                LoadCSS("monaco-editor/min/vs/editor/editor.main.css", "vs/editor/editor.main");

                // HACK: prevent race condition by loading/executing sequentially
                LoadScript("monaco-editor/min/vs/loader.js",
                    () => LoadScript("monaco-editor/min/vs/editor/editor.main.nls.js",
                        () => LoadScript("monaco-editor/min/vs/editor/editor.main.js", DelayedInit)));
            }

            CBV_color_theme_controls_inline_container.appendChild(CBV_color_theme_controls);

            CBV_enable_button.removeAttribute("disabled"); // only enable the button once the function it calls actually exists

            const params = new URLSearchParams(window.location.search);
            if (params.has("visualizer")) {
                CBV_enable_button.click();
            }

        </script>
        <!-- TODO: maybe try to find a good default font -->
        <article>
            <div style="margin: 0px auto; width:fit-content; max-width:100%">
                <h2>HLSL Constant Buffer Packing Rules</h2>
            </div>
            <div style="margin: 0px auto; width:60em; max-width:100%">
                <!-- TODO: I vs We vs ??? -->
                <h3 id="Introduction">0. Introduction</h3>
                <p>
                    Constant Buffers in HLSL have rather peculiar rules for how their individual members are laid out in memory.
                    These rules are very different from those for structures in C and C++ and very hard to practically impossible to implement in their type system.
                    This often leads to a lot of confusion and frustration when the corresponding struct layouts in the CPU and GPU code mismatch and data ends up in the wrong places as a result.
                    This article will teach you all the packing rules for constant buffers in HLSL for Direct3D 10 / Shader Model 4.0 or newer<a href="#fn:DXC" id="fnref:DXC"><sup></sup></a>.
                </p>
                <p>
                    Note that these rules are <em>not</em> the same as for HLSL structured buffers (which are pretty much equal to C) or GLSL uniform buffers (called "std140 layout").
                    I will compare and contrast with those where appropriate, but explaining all the rules for different languages/buffer types from scratch is beyond the scope of this article.
                    If you want to play around with your own constant buffers and confirm their memory layout, click the big button above (code editor not supported on mobile browsers).
                    There is a similar visualization available for C++ in
                    <a href="https://devblogs.microsoft.com/visualstudio/size-alignment-and-memory-layout-insights-for-c-classes-structs-and-unions/">Visual Studio 2022 version 17.9</a> (currently in preview as of 18 Jan 2024).
                </p>
                <p>
                    Let's start by defining what <dfn>alignment</dfn> means.
                    We say a memory address is "aligned to <var>n</var>" if it is evenly divisible by <var>n</var>, or in other words if the address is an integer multiple of <var>n</var>.
                    If a type "has an alignment [requirement] of <var>n</var>" then an instance of it must always start at a memory address aligned to <var>n</var>. The alignment <var>n</var> is always a power of two.
                </p>
                <p>
                    In HLSL, we do not have access to memory addresses / pointers, so for our purpose of defining the layout of a constant buffer,
                    we only need to care about the offset in bytes from the start of the buffer that is assigned to each member<a href="#fn:cbuffer-alignment" id="fnref:cbuffer-alignment"><sup></sup></a>.
                    The definitions of alignment work equivalently for that offset.
                    In order to maintain proper alignment for all members of a struct/buffer, it may be necessary to add invisible <dfn>padding</dfn> bytes in between them.
                </p>
                <p>
                    <div id="CBV_color_theme_controls_inline_container"><i>If you have trouble reading the examples, here are some controls for the colors and a theme switch for the whole site:</i><br /></div>
                </p>
                <h3 id="Type_Alignment">1. Type Alignment</h3>
                <p class="rule_definition" id="rule1">
                    <b>Rule #1</b>: Basic scalar types such as <code>float</code>, <code>uint</code>, <code>uint16_t</code>, etc. have a "natural" alignment requirement equal to their size. This is also called "self-alignment".
                    <br /><b>Note</b>: <code>bool</code> in HLSL is 4 bytes large!
                </p>
                <!-- NOTE: formatting doesn't matter here, we auto-format when we replace this with the actual visualization -->
                <div class="CBV_example">
                    cbuffer ExampleScalarAlignment {
                    uint16_t smol;
                    float f1;
                    float f2;
                    double lorg;
                    bool four_bytes;
                    };
                </div>
                <p>
                    <i>You can mouse over the colored struct members or the rectangles to highlight the individual elements.</i>
                </p>
                <p>
                    In the example above, there are 2 bytes of padding added after <code>smol</code> in order to align <code>f1</code> properly to a multiple of 4.
                    Similarly, <code>lorg</code> cannot start at an offset of 12 since that would not be an integer multiple of its alignment 8, resulting in an additional 4 bytes of padding in between <code>f2</code> and <code>lorg</code>.
                </p>
                <p>
                    It's pretty rare to use the 2 or 8 byte large scalar types in HLSL, but this is the most fundamental alignment rule.
                    It is common across most programming languages and target platforms because many processor architectures require the memory address of a load or store instruction to be aligned to the size of the load/store (x86 being one of the biggest exceptions).
                    Misaligned addresses may result in either a CPU exception, unexpected results (e.g. the processor may round the address down to the nearest aligned one and thus load different data) or in some cases slower execution.
                    This is why type self-alignment is very fundamental for program correctness and performance, so we make this our first rule, as it's practically universal.
                </p>
                <p>
                    Tip: If you need to supply a <code>bool</code> to HLSL in any buffer type, use an actual 4 byte type on the CPU code side (e.g. <code>windows.h</code>'s <code>BOOL</code>, <code>uint32_t</code> or your own for C/C++).
                    Do <em>not</em> use <code>alignas(4) bool</code> or manual padding (e.g. <code>bool b; char[3] pad;</code>) because you do not always have the guarantee that the internal padding bytes are zeroed out,
                    but they will actually be read by the shader regardless and thus your boolean could produce a <code>true</code> value when it shouldn't!
                </p>
                <p>
                    For the sake of completeness, the minimum-precision types (<code>min10/16*</code>) and <code>half</code> have a storage size (and thus alignment) in memory of 4 bytes by default, even though the driver compiler is
                    allowed to emit lower precision ALU instructions for the min-precision types (not <code>half</code>, which is directly mapped to <code>float</code>). When you enable native 16-bit type support via the 
                    <code>-enable-16bit-types</code> command line argument to DXC, all of those types including <code>half</code> turn into actual 16-bit types like <code>(u)int16_t</code> or <code>float16_t</code> and have a corresponding
                    size and alignment of 2 bytes, as in the examples. There are no types smaller than 4 bytes in HLSL without using DXC and this command line flag.
                </p>
                <p class="rule_definition" id="rule1a">
                    <b>Rule #1a</b>: Vector types are aligned according to their scalar component type.
                </p>
                <div class="CBV_example">
                    cbuffer ExampleVectorAlignment {
                    float f1;
                    float3 vec;
                    uint3 other_vec;
                    float f2;
                    float16_t smol;
                    int2 intvec;
                    };
                </div>
                <p>
                    This is the first rule that might bring some surprise, especially if you are familiar with GLSL uniform buffers / std140, where a <code>vec3</code> (equivalent to <code>float3</code>) would have an alignment of 16.
                    This is <em>not</em> the case in HLSL.
                    The first four members in this example all have an alignment requirement of 4 and they can all be neatly packed together, it also doesn't matter that some of them are <code>float</code>s and some are <code>uint</code>s.
                    Just like in the first example, we do incur some padding when a smaller type is followed by a larger one, but while the size of <code>intvec</code> is 8, it's alignment requirement is only 4 (based on its scalar type),
                    so only 2 bytes of padding are needed.
                </p>
                <p>
                    The rules we've covered so far are the only ones that deal with <dfn>type alignment</dfn> in constant buffers.
                    All of the following rules are entirely unique to constant buffers and only involve <dfn>variable alignment</dfn>. I'll explain the difference between these two terms as we cover more rules and examples.
                </p>
                <h3 id="Buffer_Rows">2. Buffer Rows</h3>
                <p class="rule_definition" id="rule2">
                    <b>Rule #2</b>: A Constant Buffer is arranged conceptually like an array of 16-byte rows.
                    The members of the buffer are packed into these rows and if an individual member would cross the boundary between two rows, its starting offset is forcibly aligned to 16 bytes,
                    pushing it to the start of the next row if it isn't already aligned.
                </p>
                <div class="CBV_example">
                    cbuffer ExampleBufferRows {
                    float3 position;
                    float3 normal;
                    uint index;
                    double4 d;
                    };
                </div>
                <p>
                    <i>This rule explains why I chose the visual memory layout diagrams to be in rows of 16 bytes.</i>
                </p>
                <p>
                    In this example, two <code>float3</code> members next to each other incur 4 bytes of padding in between, but this is <em>not</em> because of the inherent alignment requirement of their type (which is still 4).
                    The padding results purely from crossing a 16-byte row boundary within the buffer. It is only dependent on the size of a member and its initially desired starting offset,
                    or effectively the <em>sequence</em> of member types in the buffer. This rule does not confer alignment to a type, but to a specific individual member variable and is thus no longer a <em>type alignment</em> rule.
                    <code>normal</code> has a desired offset of 12, right at the end of <code>position</code>, but it is forcibly pushed to start at offset 16 because it does not fit entirely into the rest of the first 16-byte row.
                </p>
                <p>
                    The member <code>index</code> is packed directly after <code>normal</code> with no padding and is here to demonstrate again that <code>float3</code> does <em>not</em> actually have a type alignment of 16,
                    otherwise the size of the type itself would have to be padded to 16 as well. In C-like struct packing, the size of a type must always be an integer multiple of its alignment.
                    Otherwise, an array of that type would misalign its elements and a struct containing an overaligned type would have its layout depend on its starting address.
                    Note that HLSL has extra rules for arrays and structs which we will see later and effectively make this detail irrelevant in constant buffers.
                    The <code>double4</code> variable is too large for one row even just by itself, but its starting offset is already aligned to 16 bytes without any modification, so it stays where it is.
                </p>
                <p>
                    The above rule is probably the most confusing of them all, because only looking at the offsets may imply an increased type alignment where there is none.
                    In other languages, aligning individual variables is usually only relevant for allocating entire buffers when you do SIMD work or want cache or page alignment for other reasons.
                    HLSL is very much the odd one out with its "array of 16-byte aligned rows" design for constant buffers that affects individual struct members, so it takes some time to get used to it.
                    <a href="#fn:cbuffer-history" id="fnref:cbuffer-history"><sup></sup></a>
                </p>
                <p>
                    I usually recommend manually padding out structs in C++ and equivalently in HLSL for consistency, instead of trying to emulate this behavior with <code>alignas(16)</code>
                    (which can do either variable or type alignment depending on where you put it). For example, you could put <code>uint32_t pad0;</code> after <code>float3 position;</code>.
                    Since the 4 byte scalar types and their vectors are a large majority of constant buffer usage (apart from matrices, which we'll get to later), it can help to conceptually think of
                    your buffer as an array of <code>float4/uint4</code> elements and then assign "slots" for individual variables within those elements, leaving anything that isn't assigned as padding.
                </p>
                <p>
                    Minimum-precision types (<code>min10/16*</code>) have weird interactions with this rule when native 16-bit types are <em>not</em> enabled. In that case, min-precision types cannot be packed
                    together with regular fixed-precision types in the same row. My opinion: just don't use them.
                </p>
                <h3 id="Arrays_and_Matrices">3. Arrays and Matrices</h3>
                <p class="rule_definition" id="rule3">
                    <b>Rule #3</b>: Each element of an array starts a new 16-byte row, i.e. its starting offset is forcibly aligned to the next 16 byte boundary.
                </p>
                <div class="CBV_example">
                    cbuffer ExampleArrays {
                    float2 before;
                    float array[2];
                    float2 after;
                    };
                </div>
                <p>
                    <i>The individual array elements are expanded in this visualization to help clarify the layout. The resulting syntax isn't a legal struct declaration anymore.</i>
                <p>
                    This is one of the big pain points of constant buffers. Arrays are not packed tightly and instead must start a new 16-byte row for each element so that array indexing happens on a per-row basis,
                    leading to potentially huge gaps in between array elements.
                    This can be worked around by using larger element types (e.g. <code>float4 arr[4]</code> instead of <code>float arr[16]</code>), but then you have to use 2D indexing with division and modulo
                    (e.g. <code>arr[i / 4][i % 4]</code> or equivalently <code>arr[i >> 2][i &amp; 3]</code>) which can then <em>hopefully</em> be optimized out once you go through the driver compiler
                    (unlikely with a value only known at runtime).
                    Note that as before, we are not increasing the elements' type alignment and not increasing the size of them to full rows, we are just aligning their starting offset as if they were individual variables,
                    so the total size of <code>array</code> in this example is 20 bytes and the member <code>after</code> can be packed right at the end of the array with no additional padding.
                </p>
                <p>
                    This is annoying to deal with in C++, because if the elements do not have a size divisible by 16, you would have to do away with the array and put them as individual variables with either
                    added variable alignment via <code>alignas(16)</code> or manual padding before and in between (but not at the end!). You could also increase the size/alignment of the element type
                    (e.g. making an array of padded structs), but then you have to make sure to add padding after the array on the HLSL side because it only adds it <em>in between</em> the array elements.
                    None of these options are particularly great.
                </p>
                <p class="rule_definition" id="rule3a">
                    <b>Rule #3a</b>: Matrices are laid out equivalently to arrays of column vectors (row vectors for row-major matrices). Hence, the array size is the number of columns (rows for row-major) and the vector size is the number of rows (columns).
                    <br /><b>Exception</b>: Matrices with only one column (row for row-major) are layout-equivalent to a simple vector, not an array of one vector (i.e. they do not incur the extra 16 byte row alignment).
                    <br /><b>Note</b>: The HLSL type is always <code>typeRxC</code> with <code>R</code> being the number of rows and <code>C</code> being the number of columns
                    (matches math notation, but reverse order of GLSL/GLM's <code>matCxR</code>) and the default storage order is column-major<a href="#fn:matrix-order" id="fnref:matrix-order"><sup></sup></a>.
                </p>
                <div class="CBV_example">
                    cbuffer ExampleMatrices {
                    float2 before;
                    float2x3 mat;
                    float2x1 smol_mat;
                    };
                </div>
                <p>
                    <i>Matrices are converted into their layout-equivalent types in this visualization because it makes my job easier.</i>
                </p>
                <p>
                    Thankfully, matrices just collapse down to the types and rules we've already learned about, with the only slightly tricky part being one-column matrices
                    (note how <code>smol_mat</code> does not need to be 16-byte aligned, though those matrix dimensions do not seem particularly useful).
                    The matrix <code>mat</code> turns into an array of three <code>float2</code> vectors and we incur the excessive padding cost of arrays just as in the previous example.
                    It would be worth it to split this into three individual <code>float2 colN</code> variables to save 24 bytes of padding, though I should note that when later reconstructing the matrix in the shader,
                    HLSL always expects rows in the constructor and not columns, no matter which storage order you chose.
                </p>
                <p>
                    <i>
                        I realize that the term "row" from <a href="#rule2">Rule #2</a> concerning the 16-byte boundaries within the buffer is now overloaded with matrix rows/columns, but what can you do.
                    </i>
                </p>
                <h3 id="Inner_Structs">4. Inner Structs</h3>
                <p class="rule_definition" id="rule4">
                    <b>Rule #4</b>: Inner/nested structs must start at a 16-byte aligned offset.
                </p>
                <div class="CBV_example">
                    cbuffer ExampleInnerStructs {
                    float2 before;
                    struct Inner_t {
                    float start;
                    double d;
                    float end;
                    } inner;
                    float3 after;
                    };
                </div>
                <p>
                    Similar to array elements, inner struct variables are always forcibly aligned to start a new buffer row. As a result, we have some padding before the start of the struct in this example.
                    All the previous rules still apply within the inner struct, in this case the self-alignment requirement for <code>d</code> dictates 4 bytes of padding so it can start at an offset divisible by 8.
                </p>
                <p>
                    Of particular note here is that in C, a struct has a type alignment equivalent to the largest alignment requirement of any of its members.
                    This is to ensure all members are automatically aligned properly when the struct is constructed at an address conforming to the struct's type alignment (also including arrays of structs).
                    If we implemented this example in C, <code>Inner_t</code> would have an alignment of 8 because of the <code>double</code> sub-member and thus a size of 24
                    (the size must be a multiple of its type alignment, leading to 4 bytes of padding at the end inside the struct).
                </p>
                <p>
                    This is <em>not</em> the case in HLSL constant buffers (but it is in structured buffers!). Since the start of any struct is always forcibly aligned to 16 bytes and 16 is larger than any possible
                    type alignment requirement in HLSL, the concern of having members misaligned is nonexistent and the struct type itself never has any padding before the end to account for some inherent type alignment.
                    In fact, no type inside a constant buffer can have padding at the start or end within itself that would count towards its size, any padding is always <em>in between</em> variables or array elements.
                    Thus, <code>Inner_t</code> has a size of 20 and <code>after</code> can fit snugly in the remaining 12 bytes of the last buffer row
                    (remember that if it crossed a 16-byte row boundary it would be pushed to start at the next row in accordance with <a href="#rule2">Rule #2</a>).
                </p>
                <p>
                    This also means that this particular struct layout is very hard to implement in the C or C++ type system. You would first have to align the struct variable (not the type!) and then use your compiler's
                    equivalent of <code>__attribute__((packed))</code> to forcibly remove the padding at the end of the struct, but then also add back any padding in between the sub-members. This ends up very brittle and confusing to read.
                    It might be better to massage the HLSL side into something that is easier to translate to C
                    (I will note again that the use of anything other than 4 byte types is rare in HLSL, but I do need to explain the rules regardless).
                </p>
                <p>
                    Another consequence of this rule is that the memory layout within the inner struct is effectively independent of where it is in the buffer, because all the constant buffer rules work in alignments of 16 or smaller,
                    so the struct layout is the same whether the start offset is 0 or any other integer multiple of 16.
                    The mentioned "struct alignment equals the largest member alignment" rule for C similarly ensures the same layout independence of starting location, but in a more "fine-grained" way.
                </p>
                <h3 id="Sources_and_Methodology">5. Sources and Methodology</h3>
                <p>
                    I based the rules in this article on the following original sources:
                </p>
                <ul>
                    <li>
                        <a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-packing-rules">Packing Rules for Constant Variables (HLSL Reference, Microsoft Learn)</a>
                    </li>

                    <li>
                        <a href="https://github.com/microsoft/DirectXShaderCompiler/wiki/Buffer-Packing">Alignment and Buffer Packing (Microsoft DXC GitHub Wiki)</a> <a href="#fn:DXC-packing" id="fnref:DXC-packing"><sup></sup></a>
                    </li>
                </ul>
                <p>
                    In addition, I checked all the rules and possibly ambiguous cases using DXC and sometimes FXC. DXC is easily accessible via <a href="https://hlsl.godbolt.org/">Compiler Explorer</a>.
                    To check a buffer's layout on Compiler Explorer, you must first use it in the shader function in some way (any contrived usage will do, it just needs to not be optimized out) and then disable filtering
                    comments on the compiler output tab. Those comments show buffer layouts, resource bindings and a few other things. Also useful: you can check the actual GPU instructions emitted for AMD GPUs by switching
                    to the RGA (Radeon GPU Analyzer) compiler (this might not be 100% accurate to live testing due to differences in driver versions and because Compiler Explorer passes the shader to RGA via the SPIR-V
                    backend of DXC).
                </p>
                <hr />
                <aside>
                    <h3 id="Footnotes">Footnotes:</h3>
                    <ol>
                        <li id="fn:DXC">
                            The DXC compiler for D3D12 technically offers a command line flag to disable the "legacy" constant buffer layout rules,
                            but no graphics driver can actually interpret the resulting shader correctly, so it is unusable until we get a new shader model update formalizing the specifications and support properly.
                            <a href="#fnref:DXC">↩</a>
                        </li>
                        <li id="fn:cbuffer-alignment">
                            Constant buffers themselves are always aligned to <em>at least</em> 256 bytes, which is a much larger alignment than we will ever need to consider within it.
                            <a href="#fnref:cbuffer-alignment">↩</a>
                        </li>
                        <li id="fn:cbuffer-history">
                            The historic reason for this design is that shader constants used to be supplied via individual vector registers, not actual buffer resources, so the 16 byte rows here are the equivalent
                            of <code>float4</code> vector registers. The point is to pack the members so that a load of a single variable does not cross from one "register" to the other
                            and indexing is always done on a register-to-register basis too, not <em>within</em> a register (this will bite us hard with arrays later).
                            FXC does actually accept constant buffer struct syntax for D3D9 / Shader Model 3.0 or older, but each
                            individual member is simply put into a subsequent <code>float4</code>-sized constant register as if they were entirely unrelated variables, there is no packing at all.
                            There was no API support beyond setting the value of an individual register either (unless you count the helper library D3DX9, which just sets the registers for you under the hood).
                            This may also be related to why constant buffers declared via the <code>cbuffer</code> keyword still do not namespace their member variables without adding an inner struct.
                            <a href="#fnref:cbuffer-history">↩</a>
                        </li>
                        <li id="fn:matrix-order">
                            If you would like to firmly put your palm on your forehead, see <a target="_blank" href="HLSL matrix storage order.png">this table</a>
                            on how to (not) set a different default matrix storage order in the two major HLSL compilers. Basically, adding <code>/Zpr</code> to the command line arguments of FXC changes matrices contained within structs
                            or constant buffers to row-major, but <em>not</em> structured buffers that directly contain just a matrix (e.g. <code>StructuredBuffer&lt;float4x4&gt;</code>).
                            The <code>/Zpr</code> flag for DXC however changes <em>all</em> matrices to row-major. To emulate the old FXC behavior, DXC added <code>#pragma pack_matrix(row_major)</code> to put in your code.
                            This pragma also allows you to complete the confusion by using <code>/Zpr</code> (changes all matrices to row-major) and then also <code>#pragma pack_matrix(column_major)</code> to only change matrices
                            contained within structs or cbuffers back to column-major.
                            <a href="#fnref:matrix-order">↩</a>
                        </li>
                        <li id="fn:DXC-packing">
                            This page has a small error, it first lists the rules for structured buffers, which include "Structs are aligned by the max of it's member alignments", and then says
                            "legacy" constant buffer rules apply on top of that, which is not true for this specific rule as demonstrated in the example for <a href="#rule4">Rule #4</a>.
                            <a href="#fnref:DXC-packing">↩</a>
                        </li>
                    </ol>
                </aside>
                <!-- extra screen height so that the footnote links put you in the right place -->
                <div style="height:calc(100vh - (1.3em * 3));"></div> 

                <template id="CBV_example_template">
                    <div class="CBV_example_container">
                        <div class="CBV_left">
                            <text class="code" id="CBV_example_input"></text>
                        </div>
                        <div class="CBV_middle">
                            <text id="CBV_example_output_text" class="code">
                            </text>
                        </div>
                        <div class="CBV_right">
                            <svg id="CBV_example_output_svg" class="code">
                            </svg>
                        </div>
                    </div>
                </template>

                <script type="module">
                    import { ParseHLSLAndVisualizeTextNode, CBufferVisualizerList, CBufferVisualizerOptionsDefault } from './main.js';

                    // scale down SVG rects on very narrow screens
                    const GetRectScale = () => {
                        let example = document.querySelector(".CBV_example");
                        let container_width = parseFloat(window.getComputedStyle(example).width) - 16 /* padding */;
                        let default_rect_width = 16 * CBufferVisualizerOptionsDefault.svg_width_per_byte;
                        let rect_scale = Math.max(Math.min(container_width / default_rect_width, 1.0), 0.75);
                        return rect_scale;
                    };

                    window.addEventListener("resize", () => {
                        window.CBV_ExampleVisualizers?.SetSVGWidthPerByte(GetRectScale() * CBufferVisualizerOptionsDefault.svg_width_per_byte);
                    }, { passive: true });

                    window.CBV_ExampleVisualizers = new CBufferVisualizerList();
                    let examples = document.querySelectorAll(".CBV_example");
                    let options = window.GetVisualizerOptions();
                    options.text_alignment = 22;
                    options.color_shuffle = false;
                    options.expanded_arrays = true;
                    options.svg_width_per_byte *= GetRectScale();

                    // set up all examples with the template
                    for (let i = 0; i < examples.length; i++) {
                        let clone = CBV_example_template.content.cloneNode(true);
                        let input = clone.querySelector("#CBV_example_input");
                        let output_text = clone.querySelector("#CBV_example_output_text");
                        let output_svg = clone.querySelector("#CBV_example_output_svg");
                        input.id = input.id + i;
                        output_text.id = output_text.id + i;
                        output_svg.id = output_svg.id + i;
                        input.textContent = examples[i].textContent;
                        examples[i].replaceChildren(clone);
                        window.CBV_ExampleVisualizers.Push(ParseHLSLAndVisualizeTextNode(input, output_text, output_svg, options));
                    }

                </script>
            </div>
        </article>
    </main>
</body>
</html>