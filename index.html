<!DOCTYPE html>
<html lang="en">
<head>
    <title>HLSL Constant Buffer Packing Rules & Layout Visualizer</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="description" content="Learn HLSL constant buffer packing rules and visualize the memory layout of your own custom cbuffers!" />
    <meta name="robots" content="index, archive" />
    <meta name="keywords" content="HLSL, DirectX, Direct3D, D3D11, D3D12, DX11, DX12, constant buffer, packing rules, struct packing, struct layout, cbuffer" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:title" content="HLSL Constant Buffer Packing Rules & Layout Visualizer" />
    <meta property="og:description" content="Learn HLSL constant buffer packing rules and visualize the memory layout of your own custom cbuffers!" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://maraneshi.github.io/HLSL-ConstantBufferLayoutVisualizer/" />
    <meta property="og:image" content="https://maraneshi.github.io/HLSL-ConstantBufferLayoutVisualizer/screen3.png" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="HLSL Constant Buffer Packing Rules & Layout Visualizer" />
    <meta name="twitter:image" content="https://maraneshi.github.io/HLSL-ConstantBufferLayoutVisualizer/screen3.png" />
    <meta name="twitter:description" content="Learn HLSL constant buffer packing rules and visualize the memory layout of your own custom cbuffers!" />
    <meta name="twitter:creator" content="@maraneshi" />
    <meta name="twitter:site" content="@maraneshi" />
    <!-- NOTE: I don't know whether it's worth doing this at all. The W3 image source is there for the squiggly lines in Monaco. -->
    <META HTTP-EQUIV='Content-Security-Policy' CONTENT="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src data: 'self' w3.org/svg/2000;">
</head>
<body>
    <style>
        .code {
            font-family: Consolas, monospace;
            font-size: 14px;
            white-space: pre;
        }
        code {
            font-family: Consolas, monospace;
            white-space: pre;
            background-color: #EEEEEE;
            font-size: 0.92em;
        }
        .resizer {
            background-color: #777777;
            cursor: ew-resize;
            min-height: 100%;
            min-width:2px;
            width: 2px;
            padding: 8px;
            background-clip: content-box;
        }
        .resizer_vert {
            background-color: #777777;
            cursor: ns-resize;
            min-width: 100%;
            min-height: 2px;
            height: 2px;
            padding: 8px;
            background-clip: content-box;
        }
        :root {
            font-size: 18px;
        }
        p {
            line-height: 1.3em;
        }
        li {
            line-height: 1.3em;
            margin-block-end: 0.3em;
        }
        sup {
            line-height: 100%;
            vertical-align: top;
        }
        a {
            text-decoration:none;
        }
        a:hover {
            text-decoration:underline;
        }
        #CBV_root_container {
            font-size: initial;
            line-height: initial;
        }
        h4 {
            margin-block-start: 0.5em;
            margin-block-end: 0.5em;
        }
        .rule_definition {
            color: #2d14ad;
            padding-top: 16px;
        }
        .rule_definition > code {
            background-color: #d3ebff;
        }
        .keyword {
            color: #0000ff;
        }
        .bracket0 {
            color: #0431fa;
        }
        .bracket1 {
            color: #319331;
        }
        .bracket2 {
            color: #7b3814;
        }
        .number {
            color: #098658;
        }
        .CBV_example {
            width: calc(100% - 18px);
            padding: 8px;
            border-top: 2px solid #777777;
            border-bottom: 2px solid #777777;
            border-radius: 12px;
        }
        .CBV_left {
            flex: auto;
            margin-left: 8px;
            margin-right: 8px;
        }
        .CBV_middle {
            flex: auto;
            margin-left: 8px;
            /*margin-right: 8px;*/
            margin-right:16px; /* includes margin from CBV_right, better for mobile layout */
        }
        .CBV_right {
            flex: 1; /* this effectively aligns it to the right side */
            /*margin-left: 8px;*/
        }
        .CBV_example_container {
            margin-left: -8px; /* strip padding for mobile layout */
            margin-top: -8px; /* looks more consistent with the above */
            display: flex;
            overflow: auto;
            width: calc(100% + 8px);
            flex-wrap: wrap;
        }
        dfn {
            font-weight:bold;
            font-style:normal;
        }
        var {
            font-weight:normal;
            font-style:normal;
            font-family:math;
        }
        body {
            counter-reset: footnote;
        }
        a[href^="#fn"] ::after {
            counter-increment: footnote;
            content: counter(footnote)
        }
    </style>
    <style title="CBV Dark Theme">
        /* based on VS-Dark from Monaco */
        :root {
            color: rgb(212, 212, 212);
            background-color: rgb(30, 30, 30);
        }

        input {
            color: rgb(204, 204, 204);
            background-color: rgb(60, 60, 60);
        }

        button {
            color: rgb(255, 255, 255);
            background-color: rgb(14, 99, 156);
        }
        code {
            background-color: #3C3C3C;
        }
        .rule_definition {
            color: #A0A0F4;
        }
        .rule_definition > code {
            background-color: #251960;
        }
        a {
            color: #4e94ce;
        }
        .keyword {
            color: #569cd6;
        }
        .bracket0 {
            color: #ffd700;
        }
        .bracket1 {
            color: #da70d6;
        }
        .bracket2 {
            color: #179fff;
        }
        .number {
            color: #b5cea8;
        }
    </style>
    <main>
        <article>
            <div style="margin: 0px auto; width:fit-content; max-width:100%">
                <h2 style="margin-left:auto; margin-right:auto; width:fit-content">HLSL Constant Buffer Layout Visualizer</h2>
                <div id="CBV_enable_div" style="background-image: url(screen1a.png); background-position: center top; width: 60em; max-width: 100%; height: 146px; margin-bottom: -24px; background-repeat: no-repeat;">
                    <button id="CBV_enable_button" type="button" style="width: 17em; height: 6em; font-size: 1.1em; margin:auto; display:block; max-width:100%" disabled
                            onclick="CBV_Initialize(); this.disabled = true; this.textContent = 'Loading...'">
                        Click to Load Visualizer
                    </button>
                </div>
            </div>
            <div id="CBV_root_container" style="margin: 0px auto;  max-width:100%" hidden>
                <div style="width: 100%; display: flex; justify-content: center;">
                    <div style="float: left; flex: 0; flex-basis: auto; min-width: 20em; width:25em;">
                        <form action="javascript:CBV_VisualizeCBuffer()">
                            <div id="CBV_editor_container" style="width:100%; min-height:12em"></div>
                            <div class="resizer_vert" id="CBV_resizer_vert"></div>
                            <div>
                                <button type="submit">Parse</button>
                                <br />
                                <label for="CBV_auto_parse_delay">Auto-Parse Delay:</label>
                                <input type="range" id="CBV_auto_parse_delay" min="100" max="1500" step="50" value="500"
                                       oninput="if (this.value == this.getAttribute('max')) CBV_auto_parse_delay_value.value = 'off'; else CBV_auto_parse_delay_value.value = this.value + 'ms';" />
                                <output id="CBV_auto_parse_delay_value"></output>
                                <script>CBV_auto_parse_delay_value.value = CBV_auto_parse_delay.value;</script>
                                <br />
                                <!-- TODO: Allow these to modify any visualizer on the page -->
                                <label for="CBV_expanded_arrays">Expanded Arrays</label>
                                <input type="checkbox" id="CBV_expanded_arrays" onchange="CBV_VisualizerObject?.SetExpandedArrays(this.checked);" checked="checked" />
                                <br />
                                <label for="CBV_text_alignment">Offset Text Alignment:</label>
                                <input type="number" id="CBV_text_alignment" oninput="CBV_VisualizerObject?.SetTextAlignment(this.value);" value="28" min="10" max="200" style="width:3em;" />
                                <br />
                                <label for="CBV_color_shuffle">Shuffle Colors</label>
                                <input type="checkbox" id="CBV_color_shuffle" onchange="CBV_VisualizerObject?.SetColorShuffle(this.checked);" />
                                <br />
                                <label for="CBV_color_shuffle_subdivisions">Color Shuffle Subdivisions:</label>
                                <input type="number" id="CBV_color_shuffle_subdivisions" oninput="CBV_VisualizerObject?.SetColorShuffleSubdivisions(this.value);" value="4" min="1" max="10" style="width:2em" />
                                <br />
                                <label for="CBV_color_lightness">Color Lightness:</label>
                                <input type="range" id="CBV_color_lightness" min="0.01" max="1.0" step="0.01" value="0.60" oninput="CBV_color_lightness_value.value = this.value; CBV_VisualizerObject?.SetColorLightness(this.valueAsNumber);" />
                                <output id="CBV_color_lightness_value"></output>
                                <script>CBV_color_lightness_value.value = CBV_color_lightness.value;</script>
                                <br />
                                <label for="CBV_color_saturation">Color Saturation:</label>
                                <input type="range" id="CBV_color_saturation" min="0.01" max="1.0" step="0.01" value="0.60" oninput="CBV_color_saturation_value.value = this.value; CBV_VisualizerObject?.SetColorSaturation(this.valueAsNumber);" />
                                <output id="CBV_color_saturation_value"></output>
                                <script>CBV_color_saturation_value.value = CBV_color_saturation.value;</script>
                                <br />
                                <label for="CBV_dark_theme">Dark Theme</label>
                                <input type="checkbox" id="CBV_dark_theme" onchange="CBV_SetDarkTheme(this.checked);" checked="checked" />
                                <br />
                                <br />
                                <span>Supported Keywords:</span>
                                <br />
                                <span id="CBV_keywords_text" class="code" style="white-space:pre-wrap"></span>
                            </div>
                        </form>
                    </div>
                    <div class="resizer" id="CBV_resizer_horz"></div>
                    <div style="float: right; display:flex;">
                        <div style="float: left; flex: 1; flex-basis: max-content; padding-right: 8px">
                            <text id="CBV_output_text" class="code">
                            </text>
                        </div>
                        <div style="float: right; flex: 2; flex-basis: max-content; padding-left: 8px;">
                            <svg id="CBV_output_svg" class="code">
                            </svg>
                        </div>
                    </div>
                </div>
            </div>
        </article>

        <script>
            var require = { paths: { vs: 'monaco-editor/min/vs' } };
        </script>

        <script type="module">
            import { EnableResizer, ParseHLSLAndVisualizeMonaco, GetSupportedKeywords, SetDarkTheme, CreateMonacoEditor, CBufferVisualizerOptionsDefault } from './main.js';

            window.CBV_SetDarkTheme = SetDarkTheme;
            // TODO: add rect width and font size to options, automatically reduce width on mobile browsers (based on screen width?)
            window.GetVisualizerOptions = () => {
                let options = Object.assign({}, CBufferVisualizerOptionsDefault);
                options.expanded_arrays = CBV_expanded_arrays.checked;
                options.text_alignment = CBV_text_alignment.value;
                options.color_shuffle = CBV_color_shuffle.checked;
                options.color_shuffle_subdivisions = CBV_color_shuffle_subdivisions.value;
                options.color_lightness = CBV_color_lightness.valueAsNumber;
                options.color_saturation = CBV_color_saturation.valueAsNumber;
                options.dark_theme = CBV_dark_theme.checked;
                return options;
            }

            EnableResizer(CBV_resizer_horz, false);
            EnableResizer(CBV_resizer_vert, true);

            let keywords_str = "";
            let keywords = GetSupportedKeywords();
            for (let i = 0; i < keywords.length; i++) {
                keywords_str += keywords[i] + ((i != keywords.length - 1) ? ", " : "");
            }
            CBV_keywords_text.append(keywords_str);

            const DelayedInit = () => {
                window.CBV_monaco_editor = CreateMonacoEditor(CBV_editor_container);

                window.CBV_VisualizeCBuffer = () => {
                    window.CBV_VisualizerObject = ParseHLSLAndVisualizeMonaco(CBV_monaco_editor, CBV_output_text, CBV_output_svg, GetVisualizerOptions());
                }

                window.CBV_monaco_editor.getModel().onDidChangeContent(() => {
                    if (CBV_auto_parse_delay.value != CBV_auto_parse_delay.getAttribute("max")) {
                        clearTimeout(window.CBV_parse_timer);
                        window.CBV_parse_timer = setTimeout(CBV_VisualizeCBuffer, CBV_auto_parse_delay.value);
                    }
                });
                //window.CBV_monaco_editor.onDidContentSizeChange(() => {
                //    CBV_editor_container.style.height = `calc(max(${CBV_monaco_editor.getContentHeight() + 'px'}, ${CBV_editor_container.style.height}))`;
                //});

                CBV_VisualizeCBuffer();
                CBV_enable_div.remove();
                CBV_root_container.removeAttribute("hidden");
            }

            window.CBV_Initialize = () => {

                let link = document.createElement('link');
                link.rel = "stylesheet";
                link["data-name"] = "vs/editor/editor.main";
                link.href = "monaco-editor/min/vs/editor/editor.main.css";
                document.head.appendChild(link);

                const LoadScript = (file, callback) => {
                    let script = document.createElement('script');
                    script.src = file;
                    if (callback)
                        script.onload = callback;
                    document.body.appendChild(script);
                };

                // HACK: prevent race condition by loading sequentially
                LoadScript("monaco-editor/min/vs/loader.js",
                    () => LoadScript("monaco-editor/min/vs/editor/editor.main.nls.js",
                        () => LoadScript("monaco-editor/min/vs/editor/editor.main.js", DelayedInit)));
            }

            CBV_enable_button.removeAttribute("disabled"); // only enable the button once the function it calls actually exists

            const params = new URLSearchParams(window.location.search);
            if (params.has("visualizer"))
                window.CBV_Initialize();

        </script>
        <!-- TODO: add more examples for each rule, possibly under a foldout? -->
        <article>
            <div style="margin: 0px auto; width:fit-content; max-width:100%">
                <h2>HLSL Constant Buffer Packing Rules</h2>
            </div>
            <div style="margin: 0px auto; width:60em; max-width:100%">
                <!-- TODO: I vs We vs ??? -->
                <p>
                    Constant Buffers in HLSL have rather peculiar rules for how their individual members are laid out in memory.
                    These rules are very different from those for structures in C and C++ and very hard to practically impossible to implement in their type system.
                    This often leads to a lot of confusion and frustration when the corresponding struct layouts in the CPU and GPU code mismatch and data ends up in the wrong places as a result.
                    This article will teach you all the packing rules for constant buffers in HLSL for Direct3D 10 / Shader Model 4.0 or newer<a href="#fn:DXC" id="fnref:DXC"><sup></sup></a>.
                </p>
                <p>
                    Note that these rules are <em>not</em> the same as for HLSL structured buffers (which are very similar to C/C++) or GLSL uniform buffers (std140).
                    I will compare and contrast with those where appropriate, but explaining all the rules for different languages/buffer types from scratch is beyond the scope of this article.
                    If you want to play around with your own constant buffers and confirm their memory layout, click the big button above (not supported on mobile browsers).
                </p>
                <p>
                    Let's start by defining what <dfn>alignment</dfn> means.
                    We say a memory address is "aligned to <var>n</var>" if it is evenly divisible by <var>n</var>, or in other words if the address is an integer multiple of <var>n</var>.
                    If a type "has an alignment [requirement] of <var>n</var>" then an instance of it must always start at a memory address aligned to <var>n</var>. The alignment <var>n</var> is always a power of two.
                </p>
                <p>
                    In HLSL, we do not have access to memory addresses / pointers, so for our purpose of defining the layout of a constant buffer,
                    we only need to care about the offset in bytes from the start of the buffer that is assigned to each member<a href="#fn:cbuffer-alignment" id="fnref:cbuffer-alignment"><sup></sup></a>.
                    The definitions of alignment work equivalently for that offset.
                    In order to maintain proper alignment for each member of a struct/buffer, it may be necessary to add invisible <dfn>padding</dfn> bytes in between them.
                </p>
                <p class="rule_definition">
                    <b>Rule #1</b>: Basic scalar types such as <code>float</code>, <code>uint</code>, <code>uint16_t</code>, etc. have a "natural" alignment requirement equal to their size. This is also called "self-alignment".
                    <br /><b>Note</b>: <code>bool</code> in HLSL is 4 bytes large!
                </p>
                <!-- TODO: find better names for the individual member variables in the examples -->
                <!-- NOTE: formatting doesn't matter here, we auto-format when we replace this with the actual visualization -->
                <div class="CBV_example">
                    cbuffer ExampleScalarAlignment {
                    uint16_t smol;
                    float f1;
                    float f2;
                    double lorg;
                    bool four_bytes;
                    };
                </div>
                <p>
                    <i>You can mouse over the colored struct members or the rectangles to highlight the individual elements.</i>
                </p>
                <p>
                    In the example above, there are 2 bytes of padding added after <code>smol</code> in order to align <code>f1</code> properly to a multiple of 4.
                    Similarly, <code>lorg</code> cannot start at an offset of 12 since that would not be an integer multiple of its size 8, resulting in an additional 4 bytes of padding in between <code>f2</code> and <code>lorg</code>.
                </p>
                <p>
                    It's pretty rare to use the 2 or 8 byte large scalar types in HLSL (especially directly in buffers), but this is in a way the most fundamental alignment rule.
                    It is common across most programming languages and target platforms because many processor architectures require the memory address of a load or store instruction to be aligned to the size of the load/store (x86 being one of the biggest exceptions).
                    Misaligned addresses may result in either a CPU exception, unexpected results (e.g. the processor may round the address down to the nearest aligned one and thus load different data) or in some cases slower execution.
                    This is why type self-alignment is very fundamental for program correctness and performance, so we make this our first rule, as it's practically universal.
                </p>
                <p>
                    Tip: If you need to supply a <code>bool</code> to HLSL (in any buffer type), use an actual 4 byte type (e.g. <code>windows.h</code>'s <code>BOOL</code>, <code>uint32_t</code> or your own),
                    do <em>not</em> use <code>alignas(4) bool</code> or manual padding (e.g. <code>bool b; char[3] pad;</code>) because you do not always have the guarantee that the internal padding bytes are zeroed out,
                    but they will actually be read by the shader regardless and thus your boolean could produce a <code>true</code> value when it shouldn't!
                </p>
                <p class="rule_definition">
                    <b>Rule #1a</b>: Vector types are aligned according to their scalar component type.
                </p>
                <div class="CBV_example">
                    cbuffer ExampleVectorAlignment {
                    float f1;
                    float3 vector;
                    uint3 other_vector;
                    float f2;
                    uint16_t smol;
                    int2 intvec;
                    };
                </div>
                <p>
                    This is the first rule that might bring some surprise, especially if you are familiar with GLSL uniform buffers / std140, where a <code>vec3</code> (equivalent to <code>float3</code>) would have an alignment of 16.
                    This is <em>not</em> the case in HLSL.
                    The first four members in this example all have an alignment requirement of 4 and they can all be neatly packed together, it also doesn't matter that some of them are <code>float</code>s and some are <code>uint</code>s.
                    Just like in the first example, we do incur some padding when a smaller type is followed by a larger one, but while the size of <code>intvec</code> is 8, it's alignment requirement is only 4 (based on its scalar type),
                    so only 2 bytes of padding are needed.
                </p>
                <p>
                    The rules we've covered so far are the only ones that deal with <dfn>type alignment</dfn> in constant buffers.
                    All of the following rules are entirely unique to constant buffers and only involve <dfn>variable alignment</dfn>. I'll explain the difference between these two terms as we cover more rules and examples.
                </p>
                <p class="rule_definition" id="rule2">
                    <b>Rule #2</b>: A Constant Buffer is arranged conceptually like an array of 16-byte rows.
                    The members of the buffer are packed into these rows and if an individual member would cross the boundary between two rows, its starting offset is forcibly aligned to 16 bytes,
                    pushing it to the start of the next row if it isn't already aligned.
                </p>
                <div class="CBV_example">
                    cbuffer Example16ByteAlignment {
                    float3 position;
                    float3 normal;
                    uint index;
                    double4 d;
                    };
                </div>
                <p>
                    <i>This rule explains why I chose the visual memory layout diagrams to be in rows of 16 bytes.</i>
                </p>
                <p>
                    In this example, two <code>float3</code> members next to each other incur 4 bytes of padding in between, but this is <em>not</em> because of the inherent alignment requirement of their type (which is still 4).
                    The padding results purely from crossing a 16-byte row boundary within the buffer. It is only dependent on the size of a member and its desired starting offset,
                    or effectively the <em>sequence</em> of member types in the buffer. It is no longer a pure <em>type alignment</em> rule.
                    <code>normal</code> has a desired offset of 12, right at the end of <code>position</code>, but it is forcibly pushed to start at offset 16
                    because it does not fit entirely into the rest of the first 16-byte row.
                    The member <code>index</code> is packed directly after <code>normal</code> with no padding and is here to demonstrate again that <code>float3</code> does <em>not</em> actually have a type alignment of 16,
                    otherwise the size of the type itself would have to be padded to 16 as well<a href="#fn:aligned-size" id="fnref:aligned-size"><sup></sup></a>.
                    The <code>double4</code> variable is too large for one row even just by itself, but its starting offset is already aligned to 16 bytes without any modification, so it stays where it is.
                </p>
                <p>
                    The above rule is probably the most confusing of them all, because only looking at the offsets may imply an increased type alignment where there is none.
                    In other languages, aligning individual variables is usually only relevant for allocating entire buffers when you do SIMD work or want cache or page alignment for other reasons.
                    HLSL is very much the odd one out with its "array of 16-byte aligned rows" design for constant buffers that affects individual struct members, so it takes some time to get used to it.
                    <a href="#fn:cbuffer-history" id="fnref:cbuffer-history"><sup></sup></a>
                </p>
                <p>
                    I usually recommend manually padding out structs in C++ and equivalently in HLSL for consistency, instead of trying to emulate this behavior with <code>alignas(16)</code>
                    (which can do either variable or type alignment depending on where you put it). For example, you could put <code>uint32_t pad0;</code> after <code>float3 position;</code>.
                    Since the 4 byte scalar types and their vectors are a large majority of constant buffer usage (apart from matrices, which we'll get to later), it can help to conceptually think of
                    your buffer as an array of <code>float4/uint4</code> elements and then assign "slots" for individual variables within those elements, leaving anything that isn't assigned as padding.
                </p>
                <p class="rule_definition">
                    <b>Rule #3</b>: Each element of an array starts a new 16-byte row, i.e. its starting offset is forcibly aligned to the next 16 byte boundary.
                </p>
                <div class="CBV_example">
                    cbuffer ExampleArrays {
                    float2 before;
                    float array[2];
                    float2 after;
                    };
                </div>
                <p>
                    <i>The individual array elements are expanded in this visualization to help clarify the layout. The resulting syntax isn't a legal struct declaration anymore.</i>
                <p>
                    This is one of the big pain points of constant buffers. Arrays are not packed tightly and instead must start a new 16-byte row for each element so that array indexing happens on a per-row basis,
                    leading to potentially huge gaps in between array elements.
                    This can be worked around by using larger element types (e.g. <code>float4 arr[4]</code> instead of <code>float arr[16]</code>), but then you have to use 2D indexing with division and modulo
                    (e.g. <code>arr[i / 4][i % 4]</code> or equivalently <code>arr[i >> 2][i &amp; 3]</code>).
                    Note that as before, we are not increasing the elements' type alignment and not increasing the size of them to full rows, we are just aligning their starting offset as if they were individual variables,
                    so the total size of <code>array</code> in this example is 20 bytes and the member <code>after</code> can be packed right at the end of the array with no additional padding.
                </p>
                <p>
                    This is annoying to deal with in C++, because if the elements do not have a size divisible by 16, you would have to do away with the array and put them as individual variables with either
                    added variable alignment via <code>alignas(16)</code> or manual padding before and in between (but not at the end!). You could also increase the size/alignment of the element type
                    (e.g. making an array of padded structs), but then you have to make sure to add padding after the array on the HLSL side because it only adds it <em>in between</em> the array elements.
                    None of these options are particularly great.
                </p>
                <p class="rule_definition">
                    <b>Rule #3a</b>: Matrices are laid out equivalently to arrays of column vectors (row vectors for row-major matrices). Hence, the array size is the number of columns (rows for row-major) and the vector size is the number of rows (columns).
                    <br /><b>Exception</b>: Matrices with only one column (row for row-major) are layout-equivalent to a simple vector, not an array of one vector (i.e. they do not incur the extra 16 byte row alignment).
                    <br /><b>Note</b>: The HLSL type is always <code>typeRxC</code> with <code>R</code> being the number of rows and <code>C</code> being the number of columns
                    (matches math notation, but reverse order of GLSL/GLM's <code>matCxR</code>) and the default storage order is column-major<a href="#fn:matrix-order" id="fnref:matrix-order"><sup></sup></a>.
                </p>
                <div class="CBV_example">
                    cbuffer ExampleMatrices {
                    float2 before;
                    float2x3 mat;
                    float2x1 single_vec_mat;
                    };
                </div>
                <p>
                    <i>Matrices are converted into their layout-equivalent types in this visualization because it makes my job easier.</i>
                </p>
                <p>
                    Thankfully, matrices just collapse down to the types and rules we've already learned about, with the only slightly tricky part being one-column matrices
                    (note how <code>single_vec_mat</code> does not need to be 16-byte aligned, though those matrix dimensions do not seem particularly useful).
                    The matrix <code>mat</code> turns into an array of three <code>float2</code> vectors and we incur the excessive padding cost of arrays just as in the previous example.
                    It would be worth it to split this into three individual <code>float2 colN</code> variables to save 24 bytes of padding, though I should note that when later reconstructing the matrix in the shader,
                    HLSL always expects rows in the constructor and not columns, no matter which storage order you chose.
                </p>
                <p>
                    <i>
                        I realize that the term "row" from <a href="#rule2">Rule #2</a> concerning the 16-byte boundaries within the buffer is now overloaded with matrix rows/columns, but what can you do.
                    </i>
                </p>
                <p class="rule_definition">
                    <b>Rule #4</b>: Inner/nested structs must start at a 16-byte aligned offset.
                </p>
                <div class="CBV_example">
                    cbuffer ExampleInnerStructs {
                    float2 before;
                    struct Inner_t {
                    float start;
                    double d;
                    float end;
                    } inner;
                    float3 after;
                    };
                </div>
                <p>
                    Similar to array elements, inner struct variables are always forcibly aligned to start a new buffer row. As a result, we have some padding before the start of the struct in this example.
                    All the previous rules still apply within the inner struct, in this case the self-alignment requirement for <code>d</code> dictates 4 bytes of padding so it can start at an offset divisible by 8.
                </p>
                <p>
                    Of particular note here is that in C, a struct has a type alignment equivalent to the largest alignment requirement of any of its members.
                    This is to ensure all members are automatically aligned properly when the struct is constructed at an address conforming to the struct's type alignment (also including arrays of structs).
                    If we implemented this example in C, <code>Inner_t</code> would have an alignment of 8 (because of the <code>double</code> member) and thus a size of 24
                    (the size must be a multiple of the type alignment, leading to 4 bytes of padding at the end inside the struct).
                </p>
                <p>
                    This is <em>not</em> the case in HLSL constant buffers (but it is in structured buffers!). Since the start of any struct is always forcibly aligned to 16 bytes and 16 is larger than any possible
                    type alignment requirement in HLSL, the concern of having members misaligned is nonexistent and the struct type itself never has any padding before the end to account for some inherent type alignment.
                    In fact, no type inside a constant buffer can have padding at the start or end within itself that would count towards its size, any padding is always <em>in between</em> variables or array elements.
                    Thus, <code>Inner_t</code> has a size of 20 and <code>after</code> can fit snugly in the remaining 12 bytes of the last buffer row
                    (remember that if it crossed a 16-byte row boundary it would be pushed to start at the next row in accordance with <a href="#rule2">Rule #2</a>).
                </p>
                <p>
                    This also means that this particular struct layout is very hard to implement in the C or C++ type system. You would first have to align the struct variable (not the type!) and then use your compiler's
                    equivalent of <code>__attribute__((packed))</code> to forcibly remove the padding at the end of the struct, but then also add back any padding in between the sub-members. This ends up very brittle and confusing to read.
                    It might be better to massage the HLSL side into something that is easier to translate to C
                    (I will note again that the use of anything other than 4 byte types is rare in HLSL, but I do need to explain the rules regardless).
                </p>
                <p>
                    Another consequence of this rule is that the memory layout within the inner struct is effectively independent of where it is in the buffer, because all the rules work in alignments of 16 or smaller,
                    so the struct layout is the same whether the start offset is 0 or any other integer multiple of 16.
                </p>
                <p>
                    The end. We've done it. These are all the rules you need. [TODO: write some sort of outro here]
                </p>
                <hr />
                <aside>
                    <h3>Footnotes:</h3>
                    <ol>
                        <li id="fn:DXC">
                            The DXC compiler for D3D12 technically offers a command line flag to disable the "legacy" constant buffer layout rules,
                            but no graphics driver can actually interpret the resulting shader correctly, so it is unusable until we get a new shader model update formalizing the specifications and support properly.
                            <a href="#fnref:DXC">↩</a>
                        </li>
                        <li id="fn:cbuffer-alignment">
                            Constant buffers themselves are always aligned to <em>at least</em> 256 bytes, which is a much larger alignment than we will ever need to consider within it.
                            <a href="#fnref:cbuffer-alignment">↩</a>
                        </li>
                        <li id="fn:aligned-size">
                            !!! TODO: I feel like this has to be in the main text to really drive the point home, but I don't quite know how to work it in. <br />
                            In C-like struct packing, the size of a type must always be an integer multiple of its alignment. Otherwise, an array of that type would misalign its elements and
                            a struct containing an overaligned type would have its layout depend on its starting address.
                            Note that HLSL has extra rules for arrays and structs which effectively make this detail irrelevant in constant buffers. Continue reading.
                            <a href="#fnref:aligned-size">↩</a>
                        </li>
                        <li id="fn:cbuffer-history">
                            The historic reason for this design is that shader constants used to be supplied via individual vector registers, not actual buffer resources, so the 16 byte rows here are the equivalent
                            of <code>float4</code> vector registers. The point is to pack the members so that a load of a single variable does not cross from one "register" to the other
                            and indexing is always done on a register-to-register basis too, not <em>within</em> a register (this will bite us hard with arrays later).
                            FXC does actually accept constant buffer struct syntax for D3D9 / Shader Model 3.0 or older, but each
                            individual member is simply put into a subsequent <code>float4</code>-sized constant register as if they were entirely unrelated variables, there is no packing at all.
                            There was no API support beyond setting the value of an individual register either (unless you count the helper library D3DX9, which just sets the registers for you under the hood).
                            This may also be related to why constant buffers declared via the <code>cbuffer</code> keyword still do not namespace their member variables without adding an inner struct.
                            <a href="#fnref:cbuffer-history">↩</a>
                        </li>
                        <li id="fn:matrix-order">
                            If you would like to firmly put your palm on your forehead, see <a target="_blank" href="HLSL matrix storage order.png">this table</a>
                            on how to (not) set a different default matrix storage order in the two major HLSL compilers.
                            <a href="#fnref:matrix-order">↩</a>
                        </li>
                    </ol>
                </aside>

                <!-- TODO: scale down rects on small screens-->
                <template id="CBV_example_template">
                    <div class="CBV_example_container">
                        <div class="CBV_left">
                            <text class="code" id="CBV_example_input"></text>
                        </div>
                        <div class="CBV_middle">
                            <text id="CBV_example_output_text" class="code">
                            </text>
                        </div>
                        <div class="CBV_right">
                            <svg id="CBV_example_output_svg" class="code">
                            </svg>
                        </div>
                    </div>
                </template>
                <script type="module">
                    import { ParseHLSLAndVisualizeTextNode } from './main.js';
                    // set up all examples with this template
                    let examples = document.querySelectorAll(".CBV_example");
                    let options = GetVisualizerOptions();
                    options.text_alignment = 24;

                    for (let i = 0; i < examples.length; i++) {
                        let clone = CBV_example_template.content.cloneNode(true);
                        let input = clone.querySelector("#CBV_example_input");
                        let output_text = clone.querySelector("#CBV_example_output_text");
                        let output_svg = clone.querySelector("#CBV_example_output_svg");
                        input.id = input.id + i;
                        output_text.id = output_text.id + i;
                        output_svg.id = output_svg.id + i;
                        input.textContent = examples[i].textContent;
                        examples[i].replaceChildren(clone);
                        ParseHLSLAndVisualizeTextNode(input, output_text, output_svg, options);
                    }
                </script>
            </div>
        </article>
    </main>
</body>
</html>