<!DOCTYPE html>
<html lang="en">
<head>
    <!-- TODO: add OpenGraph/Twitter embed info -->
    <title>HLSL Constant Buffer Packing Rules & Layout Visualizer</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="description" content="HLSL Constant Buffer Packing Rules and Layout Visualizer" />
    <meta name="robots" content="index, archive" />
    <meta name="keywords" content="HLSL, DirectX, Direct3D, D3D11, D3D12, DX11, DX12, constant buffer, packing rules, struct packing, struct layout, cbuffer" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- NOTE: I don't know whether it's worth doing this at all. The W3 image source is there for the squiggly lines in Monaco. -->
    <META HTTP-EQUIV='Content-Security-Policy' CONTENT="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src data: 'self' w3.org/svg/2000;">

</head>
<body>
    <style>
        .code {
            font-family: Consolas, monospace;
            font-size: 14px;
            white-space: pre;
        }
        .resizer {
            background-color: #777777;
            cursor: ew-resize;
            min-height: 100%;
            min-width:2px;
            width: 2px;
            padding: 8px;
            background-clip: content-box;
        }
        .resizer_vert {
            background-color: #777777;
            cursor: ns-resize;
            min-width: 100%;
            min-height: 2px;
            height: 2px;
            padding: 8px;
            background-clip: content-box;
        }
        :root {
            font-size: 18px;
        }
        p {
            line-height: 1.3em;
        }
        li {
            line-height: 1.3em;
            margin-block-end: 0.3em;
        }
        sup {
            line-height: 100%;
            vertical-align: top;
        }
        #CBV_root_container {
            font-size: initial;
            line-height: initial;
        }
        h4 {
            margin-block-start: 0.5em;
            margin-block-end: 0.5em;
        }
        .keyword {
            color: #0000ff;
        }
        .bracket0 {
            color: #0431fa;
        }
        .bracket1 {
            color: #319331;
        }
        .bracket2 {
            color: #7b3814;
        }
        .number {
            color: #098658;
        }
        .CBV_example {
            width: 100%;
            overflow: auto;
        }
        dfn {
            font-weight:bold;
            font-style:normal;
        }
        var {
            font-weight:normal;
            font-style:normal;
            font-family:math;
        }
    </style>
    <style title="CBV Dark Theme">
        /* based on VS-Dark from Monaco */
        :root {
            color: rgb(212, 212, 212);
            background-color: rgb(30, 30, 30);
        }

        input {
            color: rgb(204, 204, 204);
            background-color: rgb(60, 60, 60);
        }

        button {
            color: rgb(255, 255, 255);
            background-color: rgb(14, 99, 156);
        }
        a {
            color: #4e94ce;
            text-decoration:none;
        }
        a:hover {
            text-decoration:underline;
        }
        .keyword {
            color: #569cd6;
        }
        .bracket0 {
            color: #ffd700;
        }
        .bracket1 {
            color: #da70d6;
        }
        .bracket2 {
            color: #179fff;
        }
        .number {
            color: #b5cea8;
        }
    </style>
    <main>
        <article>
            <div style="margin: 0px auto; width:fit-content; max-width:100%">
                <h2>HLSL Constant Buffer Layout Visualizer</h2>
                <button id="CBV_enable_button" type="button" style="width: 17em; height: 6em; font-size: 1.1em; margin:auto; display:block; max-width:100%" disabled
                        onclick="CBV_Initialize(); this.disabled = true; this.textContent = 'Loading...'">Click to Load Visualizer</button>
            </div>
            <div id="CBV_root_container" style="margin: 0px auto;  max-width:100%" hidden>
                <div style="width: 100%; display: flex; justify-content: center;">
                    <div style="float: left; flex: 0; flex-basis: auto; min-width: 20em; width:25em;">
                        <form action="javascript:CBV_VisualizeCBuffer()">
                            <div id="CBV_editor_container" style="width:100%; min-height:12em"></div>
                            <div class="resizer_vert" id="CBV_resizer_vert"></div>
                            <div>
                                <button type="submit">Parse</button>
                                <br />
                                <label for="CBV_auto_parse_delay">Auto-Parse Delay:</label>
                                <input type="range" id="CBV_auto_parse_delay" min="100" max="1500" step="50" value="500"
                                       oninput="if (this.value == this.getAttribute('max')) CBV_auto_parse_delay_value.value = 'off'; else CBV_auto_parse_delay_value.value = this.value + 'ms';" />
                                <output id="CBV_auto_parse_delay_value"></output>
                                <script>CBV_auto_parse_delay_value.value = CBV_auto_parse_delay.value;</script>
                                <br />
                                <!-- TODO: Allow these to modify any visualizer on the page -->
                                <label for="CBV_expanded_arrays">Expanded Arrays</label>
                                <input type="checkbox" id="CBV_expanded_arrays" onchange="CBV_VisualizerObject?.SetExpandedArrays(this.checked);" checked="checked" />
                                <br />
                                <label for="CBV_text_alignment">Offset Text Alignment:</label>
                                <input type="number" id="CBV_text_alignment" oninput="CBV_VisualizerObject?.SetTextAlignment(this.value);" value="28" min="10" max="200" style="width:3em;" />
                                <br />
                                <label for="CBV_color_shuffle">Shuffle Colors</label>
                                <input type="checkbox" id="CBV_color_shuffle" onchange="CBV_VisualizerObject?.SetColorShuffle(this.checked);" />
                                <br />
                                <label for="CBV_color_shuffle_subdivisions">Color Shuffle Subdivisions:</label>
                                <input type="number" id="CBV_color_shuffle_subdivisions" oninput="CBV_VisualizerObject?.SetColorShuffleSubdivisions(this.value);" value="4" min="1" max="10" style="width:2em" />
                                <br />
                                <label for="CBV_color_lightness">Color Lightness:</label>
                                <input type="range" id="CBV_color_lightness" min="0.01" max="1.0" step="0.01" value="0.60" oninput="CBV_color_lightness_value.value = this.value; CBV_VisualizerObject?.SetColorLightness(this.valueAsNumber);" />
                                <output id="CBV_color_lightness_value"></output>
                                <script>CBV_color_lightness_value.value = CBV_color_lightness.value;</script>
                                <br />
                                <label for="CBV_color_saturation">Color Saturation:</label>
                                <input type="range" id="CBV_color_saturation" min="0.01" max="1.0" step="0.01" value="0.60" oninput="CBV_color_saturation_value.value = this.value; CBV_VisualizerObject?.SetColorSaturation(this.valueAsNumber);" />
                                <output id="CBV_color_saturation_value"></output>
                                <script>CBV_color_saturation_value.value = CBV_color_saturation.value;</script>
                                <br />
                                <label for="CBV_dark_theme">Dark Theme</label>
                                <input type="checkbox" id="CBV_dark_theme" onchange="CBV_SetDarkTheme(this.checked);" checked="checked" />
                                <br />
                                <br />
                                <span>Supported Keywords:</span>
                                <br />
                                <span id="CBV_keywords_text" class="code" style="white-space:pre-wrap"></span>
                            </div>
                        </form>
                    </div>
                    <div class="resizer" id="CBV_resizer_horz"></div>
                    <div style="float: right; display:flex;">
                        <div style="float: left; flex: 1; flex-basis: max-content; padding-right: 24px">
                            <text id="CBV_output_text" class="code">
                            </text>
                        </div>
                        <div style="float: right; flex: 2; flex-basis: max-content; padding-left: 24px;">
                            <svg id="CBV_output_svg" class="code">
                            </svg>
                        </div>
                    </div>
                </div>
            </div>
        </article>

        <script>
            var require = { paths: { vs: 'monaco-editor/min/vs' } };
        </script>

        <script type="module">
            import { EnableResizer, ParseHLSLAndVisualizeMonaco, GetSupportedKeywords, SetDarkTheme, CreateMonacoEditor, CBufferVisualizerOptionsDefault } from './main.js';

            window.CBV_SetDarkTheme = SetDarkTheme;

            window.GetVisualizerOptions = () => {
                let options = Object.assign({}, CBufferVisualizerOptionsDefault);
                options.expanded_arrays = CBV_expanded_arrays.checked;
                options.text_alignment = CBV_text_alignment.value;
                options.color_shuffle = CBV_color_shuffle.checked;
                options.color_shuffle_subdivisions = CBV_color_shuffle_subdivisions.value;
                options.color_lightness = CBV_color_lightness.valueAsNumber;
                options.color_saturation = CBV_color_saturation.valueAsNumber;
                options.dark_theme = CBV_dark_theme.checked;
                return options;
            }

            EnableResizer(CBV_resizer_horz, false);
            EnableResizer(CBV_resizer_vert, true);

            let keywords_str = "";
            let keywords = GetSupportedKeywords();
            for (let i = 0; i < keywords.length; i++) {
                keywords_str += keywords[i] + ((i != keywords.length - 1) ? ", " : "");
            }
            CBV_keywords_text.append(keywords_str);

            const DelayedInit = () => {
                window.CBV_monaco_editor = CreateMonacoEditor(CBV_editor_container);

                window.CBV_VisualizeCBuffer = () => {
                    window.CBV_VisualizerObject = ParseHLSLAndVisualizeMonaco(CBV_monaco_editor, CBV_output_text, CBV_output_svg, GetVisualizerOptions());
                }

                window.CBV_monaco_editor.getModel().onDidChangeContent(() => {
                    if (CBV_auto_parse_delay.value != CBV_auto_parse_delay.getAttribute("max")) {
                        clearTimeout(window.CBV_parse_timer);
                        window.CBV_parse_timer = setTimeout(CBV_VisualizeCBuffer, CBV_auto_parse_delay.value);
                    }
                });
                //window.CBV_monaco_editor.onDidContentSizeChange(() => {
                //    CBV_editor_container.style.height = `calc(max(${CBV_monaco_editor.getContentHeight() + 'px'}, ${CBV_editor_container.style.height}))`;
                //});

                CBV_VisualizeCBuffer();
                CBV_enable_button.style.display = 'none';
                CBV_root_container.hidden = false;
            }

            window.CBV_Initialize = () => {

                let link = document.createElement('link');
                link.rel = "stylesheet";
                link["data-name"] = "vs/editor/editor.main";
                link.href = "monaco-editor/min/vs/editor/editor.main.css";
                document.head.appendChild(link);

                const LoadScript = (file, callback) => {
                    let script = document.createElement('script');
                    script.src = file;
                    if (callback)
                        script.onload = callback;
                    document.body.appendChild(script);
                };

                // HACK: prevent race condition by loading sequentially
                LoadScript("monaco-editor/min/vs/loader.js",
                    () => LoadScript("monaco-editor/min/vs/editor/editor.main.nls.js",
                        () => LoadScript("monaco-editor/min/vs/editor/editor.main.js", DelayedInit)));
            }

            CBV_enable_button.removeAttribute("disabled"); // only enable the button once the function it calls actually exists
        </script>

        <!-- TODO: Write actual article about rules -->
        <article>
            <div style="margin: 0px auto; width:fit-content; max-width:100%">
                <h2>HLSL Constant Buffer Packing Rules</h2>
            </div>
            <div style="margin: 0px auto; width:60em; max-width:100%">
                <p>
                    Constant Buffers in HLSL have rather peculiar rules for how their individual members are laid out in memory.
                    These rules are very different from those for structures in C and C++ and in fact practically impossible to implement in their type system.
                    This often leads to a lot of confusion and frustration when the corresponding struct layouts in the CPU and GPU code mismatch and data ends up in the wrong places as a result.
                    This article will teach you all the packing rules for constant buffers in HLSL for Shader Model 4.0 / Direct3D 10 or newer<a href="#fn:DXC" id="fnref:DXC"><sup>1</sup></a>.
                </p>
                <p>
                    Let's start by defining what <dfn>alignment</dfn> means. Each member of a structure is assigned an offset in bytes from the start of the struct.
                    We say an offset is "aligned to <var>n</var>" if it is evenly divisible by <var>n</var>.
                    If something "has an alignment [requirement] of <var>n</var>" then it must always start at an offset aligned to <var>n</var>.
                    <a href="#fn:alignment" id="fnref:alignment"><sup>2</sup></a>
                    In order to maintain proper alignment, it may be necessary to add invisible <dfn>padding</dfn> bytes in between struct members.
                </p>
                <p>
                    TODO: This is a work in progress...
                </p>
                <!-- NOTE: formatting doesn't matter here, we auto-format when we replace this with the actual visualization -->
                <div class="CBV_example">
                    cbuffer TestExample {
                    float3 a, b;
                    };
                </div>

                <!-- TODO: This layout doesn't quite work on mobile -->
                <template id="CBV_example_template">
                    <div style="float: left;">
                        <text class="code" id="CBV_example_input"></text>
                    </div>
                    <div style="float: right;">
                        <div style="float: left; padding-left: 24px; padding-right: 24px; ">
                            <text id="CBV_example_output_text" class="code">
                            </text>
                        </div>
                        <div style="float: right; padding-left: 24px;">
                            <svg id="CBV_example_output_svg" class="code">
                            </svg>
                        </div>
                    </div>
                </template>
                <script type="module">
                    import { ParseHLSLAndVisualizeTextNode } from './main.js';
                    // set up all examples with this template
                    let examples = document.querySelectorAll(".CBV_example");

                    for (let i = 0; i < examples.length; i++) {
                        let clone = CBV_example_template.content.cloneNode(true);
                        let input = clone.querySelector("#CBV_example_input");
                        let output_text = clone.querySelector("#CBV_example_output_text");
                        let output_svg = clone.querySelector("#CBV_example_output_svg");
                        input.id = input.id + i;
                        output_text.id = output_text.id + i;
                        output_svg.id = output_svg.id + i;
                        input.textContent = examples[i].textContent;
                        examples[i].replaceChildren(clone);
                        ParseHLSLAndVisualizeTextNode(input, output_text, output_svg, GetVisualizerOptions());
                    }
                </script>
                <hr />
                <aside>
                    <h3>Footnotes:</h3>
                    <ol>
                        <li id=fn:DXC>
                            The DXC compiler for D3D12 technically offers a command line flag to disable the "legacy" constant buffer layout rules,
                            but no graphics driver can actually implement it correctly, so it is unusable. <a href="#fnref:DXC">↩</a>
                        </li>
                        <li id=fn:alignment>
                            Technically alignment would usually refer to <em>memory addresses</em> instead of the byte offset within a struct,
                            but in most cases it ends up equivalent and we don't even have access to pointers in HLSL anyways. The offset is all that matters for our purposes. <a href="#fnref:alignment">↩</a>
                        </li>
                    </ol>
                </aside>
            </div>
        </article>
    </main>
</body>
</html>